package main

import (
	"turing/algo"
)

func main() {
	// file, err := os.Open("./data/adj1")
	// if err != nil {
	// 	log.Fatal(err)
	// }
	// defer file.Close()

	// worldMap := [][]rune{
	// 	[]rune{'W', 'L', 'W', 'W', 'L', 'W'},
	// 	[]rune{'L', 'L', 'W', 'L', 'L', 'W'},
	// 	[]rune{'W', 'L', 'W', 'L', 'L', 'W'},
	// 	[]rune{'W', 'L', 'W', 'L', 'L', 'W'},
	// 	[]rune{'W', 'L', 'W', 'L', 'W', 'W'},
	// 	[]rune{'W', 'L', 'W', 'W', 'W', 'W'},
	// }

	// listP := []int{1, 2, 3, 4, 5, 6}
	// listS := []int{}
	// listS := []int{1, 2}

	// cost := []int{1, 1, 3, 1, 1}
	// gas := []int{1, 2, 1, 1, 2}
	// fmt.Println(exercises.GetStartingGasStation(gas, cost))

	algo.TestBinarySearch()
	// algo.TestDFS()
	// fmt.Println(graph.CanFinishCourses(6, [][]int{{3, 0}, {1, 3}, {2, 1}, {4, 1}, {4, 2}, {5, 3}, {5, 4}}))
	// fmt.Println(exercises.GenerateParentheses(8))
	// fmt.Println(tree.IsSymmetric(tree.Tree))
	// fmt.Println(exercises.FindFirstLastPositionOfTarget([]int{1, 3, 2, 2}, 2))
	// fmt.Println(exercises.Anagrams("hasa", "saah"))

	// fmt.Println(tree.BinaryTreeSum(tree.Tree))
	// fmt.Println(tree.BinaryTreeMininum(tree.Tree))
	// fmt.Println(tree.MaxPathSum(tree.Tree))
	// list.PrintList(list.ZipperList(list.ParseSlice(listS), list.ParseSlice(listP)))
	// list.PrintList(list.Reverse(list.ParseSlice(listS)))

	// fmt.Println(IslandCount(ParseMap(worldMap)))

	// list := scanner.BuildAdjList(file, false)
	// NewGraph(list)
	// fmt.Println(FindShortestPath(2, 4))
	// FindLargestComponent()
	// DFSFrom(3)
	// FindComponents()
	// fmt.Println(HasPath(2, 0))
	// fmt.Println(list)
	// fmt.Println(TraversalPath())
	// fmt.Println(Components())

}
